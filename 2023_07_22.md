# 6198 옥상 정원 꾸미기
```kotlin
6 // n
10
3
7
4
12
2
```
- 10에서 3,7,4를 확인할 수 있다.
- 3에서는 아무것도 확인할 수 없다.
- 7에서는 4를 확인할 수 있다.
- 4에서는 아무것도 확인할 수 없다.
- 12에서는 2를 확인할 수 있다.
- 2에서는 아무것도 확인할 수 없다.

자기보다 큰 수가 나올 때가지 카운트 해야 하는 것인디.. 이러면 당연히 n 제곱이 될 것이고.. 
스택이 아직 감이 안 오나 보다 ㅠ 

어떤 시점에서 스택에 쌓여있는 과거의 값들과 비교를 하여 pop을 수행하고 자기 자신을 push해야 한다.
이 문제의 경우를 생각해보자.
- 10 : push 
- 3 : top(10)이 자신보다 크므로 pop할 수 없다. 3을 push한다.
- 7 : top(3)이 자신보다 작으므로 pop한다. (7과의 인덱스 차이 - 1)인 0을 누적한다. 그리고 7을 누적한다. 
이때 누적하는 값은 3이 볼 수 있는 빌딩의 개수이다. 7을 push한다.
- 4 : top(7)이 자신보다 크므로 pop할 수 없다. 4를 push한다.
- 12 : 12보다 큰 값이 나올때까지 pop한다. 각 빌딩에 대해 (12와의 인덱스 차이 -1)을 누적한다. 
이것은 각 빌딩이 볼 수 있는 빌딩의 개수이다. 12를 push한다.
- 2 : top(12)이 자신보다 크므로 pop할 수 없다. 2를 push한다.
- iteration이 끝난 뒤 : 스택에 12와 2가 있는 상황. 뒤에 있는 빌딩들 (각 1개, 0개)을 볼 수 있다. 
이것도 인덱스를 활용하면 (빌딩 사이즈 - 인덱스)를 누적하면 된다.

# 

```kotlin
/**
초기값 = 0
1~N -> X번째 카운터 +1
N+1 -> 모든 카운터를 max값으로 통일
시간복잡도를 낮추기 위해.. max 호출을 최적화할 필요가 있다!

어떤 시점에서 + 호출이 들어왔을 때 현재 max(max호출로 설정된 값)보다 작다면 max를 더해준 뒤에 +해준다.
마지막 max보다 작다면 값이 업데이트 되지 않은 것이므로 max로 설정해준다.
 **/
fun solution(N: Int, A: IntArray): IntArray {
    val arr = IntArray(N) { 0 }
    var max = 0 // 현재 최댓값
    var lastMax = 0 // max 호출로 인한 최댓값
    A.forEach {
        if (it <= N) { // + 호출
            if (it < lastMax) arr[it - 1] = lastMax
            arr[it - 1]++
            max = maxOf(arr[it - 1], max) // 최댓값 업데이트
        } else lastMax = max
    }
    for (i in arr.indices) {
        if (arr[i] < lastMax) arr[i] = lastMax
    }
    return arr
}

```
